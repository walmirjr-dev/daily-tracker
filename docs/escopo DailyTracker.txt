Escopo inicial do projeto DailyTracker. O projeto está sendo desenvolvido para eu registrar meus dias de estudo avulso diário de acordo com uma meta em relação ao ano.


O usuário (eu) poderá criar um desafio, este desafio contém: nome, duração(em dias), data inicial(data da criação), após sua criação, uma interface limpa deverá conter, em checkmarks(quadrados), a quantidade definida na duração (100 dias = 100 checkmarks.), todos checkmarks começarão vazios, e haverá um botão para registrar CheckIn, ao regisrar o checkin, o primeiro quadrado, da esquerda para direita será marcado com um check ou em cor verde, indicando que foi completado, o usuário poderá registrar checksins referentes a dias que já passaram, para caso de não se lembrar de marcar num dia e querer mesmo assim registrar, mas não para dias que ainda não chegaram, por exemplo, se um desafio for iniciado no dia 02/02/26 e o usuário não registrar nenhum checkin até o dia 05/02, ele poderá realizar 4 checkins de uma vez se quiser, referente aos dias que passaram, porém não poderá registrar um quinto checkin, pois seguindo a lógica de um checkin por dia, é impossível ter 5 checkins em 4 dias. Cada quadrado deverá ser preenchido em sequência, para mostrar linearidade, além dos quadrados, deverá também ter um indicador mostrando a data final do desafio e um indicador mostrando, em porcentagem, o progesso do usuário em seus checkins.



mudança de paradigma: o jeito que o código estava implementado, dava uma ideia de continuidade (streak), que eu não queria, o jeito
que o código estava estruturado passava uma ideia diferente do que o escopo inicial e minha intenção inicial diziam, agora, deixei a visão do sistema como um alcance de metas (milestones), deixando de acordo com a ideia inicial.

diferenças: o código antes estava estruturado de uma forma em que ao instanciar um desafio, o usuário definia data inicial(initialDate) e duração de dias(durationDays), e o sistema começava  a contar os dias restantes a partir do atributo endDate, que basicamente era (initialDate + durationDays), ou seja, minha meta de estudar por 200 dias até o fim do ano não funcionaria do jeito que quero, pois o sistema contava 200 dias restantes corridos a partir da data inicial, então se eu ficasse um dia sem estudar, já não teria como completar os 200 dias.
	Então eu mudei o paradigma e como o sistema enxerga isso, agora, durationDays virou targetDays(dias de meta), e o atributo endDate agora é definido pelo usuário, então para minha meta de estudar por 200 dias até o fim do ano, ficara assim.

initialDate: 01/02/2026
targetDays: 200
endDate: 31/12/2026

Agora eu teria tempo para cumprir minha meta, mesmo que um dia ou outro eu não estudasse, por descanso ou questões pessoais que impossibilitassem.